// Generated by CoffeeScript 1.8.0
(function() {
  var isAlphanum, isLowercase, isNumeric, isUppercase, matching,
    __slice = [].slice;

  matching = function(candidate, term, hitTag) {
    var ai, cacy, cap, char, cumulation, endTag, hit, hits, i, ie, lastSplit, originalChar, score, splittedText, startTag, tagend, tagstart, termi, text, texti, ucterm, uctext, _i, _len;
    text = candidate.text;
    cacy = candidate.acronym;
    uctext = text.toUpperCase();
    ucterm = term.toUpperCase();
    score = 1;
    hits = [];
    ai = 0;
    texti = -1;
    termi = 0;
    while (termi < ucterm.length) {
      char = ucterm.charCodeAt(termi);
      if (ai < cacy.length && char === uctext.charCodeAt(cacy[ai])) {
        texti = cacy[ai];
        score += term.charCodeAt(termi) === text.charCodeAt(cacy[ai]) ? 41 : 30;
        ai += 1;
      } else {
        texti = uctext.indexOf(ucterm[termi], texti + 1);
        while (ai < cacy.length && texti > cacy[ai]) {
          ai += 1;
        }
        if (texti === -1) {
          return null;
        }
      }
      hits.push(texti);
      termi += 1;
    }
    if (hits.length !== term.length) {
      return null;
    }
    for (_i = 0, _len = hits.length; _i < _len; _i++) {
      hit = hits[_i];
      originalChar = text.charCodeAt(hit);
    }
    if (text.length > 4) {
      score += 20;
    }
    i = 0;
    splittedText = [];
    lastSplit = 0;
    while (i < hits.length) {
      ie = i;
      while (true) {
        ie += 1;
        if (ie >= hits.length || hits[ie] !== hits[ie - 1] + 1) {
          break;
        }
      }
      score += (ie - i - 1) * 17;
      tagstart = hits[i];
      tagend = hits[ie - 1] + 1;
      splittedText.push(text.slice(lastSplit, tagstart));
      lastSplit = tagstart;
      splittedText.push(text.slice(lastSplit, tagend));
      lastSplit = tagend;
      i = ie;
    }
    cap = text.slice(lastSplit, text.length);
    i = 0;
    cumulation = '';
    startTag = '<span class="' + hitTag + '">';
    endTag = '</span>';
    while (i < splittedText.length) {
      cumulation += splittedText[i] + startTag + splittedText[i + 1] + endTag;
      i += 2;
    }
    return {
      score: score,
      matched: cumulation + cap
    };
  };

  isLowercase = function(charcode) {
    return charcode >= 97 && charcode <= 122;
  };

  isUppercase = function(charcode) {
    return charcode >= 65 && charcode <= 90;
  };

  isNumeric = function(charcode) {
    return charcode >= 48 && charcode <= 57;
  };

  isAlphanum = function(charcode) {
    return (isLowercase(charcode)) || (isUppercase(charcode)) || (isNumeric(charcode));
  };

  this.MatchSet = (function() {
    function MatchSet() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 1) {
        this.takeSet(args[0]);
      }
    }

    MatchSet.prototype.takeSet = function(termArray) {
      var ar, charcode, i, j, text, _i, _ref, _results;
      if (termArray.length > 0) {
        if (termArray[0].constructor === String) {
          termArray = termArray.map(function(st, i) {
            return [st, i];
          });
        }
      }
      this.set = new Array(termArray.length);
      _results = [];
      for (i = _i = 0, _ref = termArray.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        text = termArray[i][0];
        _results.push(this.set[i] = {
          text: text,
          key: termArray[i][1],
          acronym: ((function() {
            var _j, _ref1;
            ar = [];
            if (text.length > 0) {
              for (j = _j = 0, _ref1 = text.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
                charcode = text.charCodeAt(j);
                if ((isUppercase(charcode)) || isAlphanum(charcode) && (j === 0 || !isAlphanum(text.charCodeAt(j - 1)))) {
                  ar.push(j);
                }
              }
            }
            return ar;
          })())
        });
      }
      return _results;
    };

    MatchSet.prototype.seek = function(searchTerm, nresults, hitTag) {
      var c, ci, insertat, minscore, retar, sr, _i, _j, _ref, _ref1;
      if (nresults == null) {
        nresults = 10;
      }
      if (hitTag == null) {
        hitTag = 'subsequence_matching';
      }
      if (this.set.length === 0 || nresults === 0 || searchTerm.length === 0) {
        return [];
      }
      retar = [];
      minscore = 0;
      for (ci = _i = 0, _ref = this.set.length; 0 <= _ref ? _i < _ref : _i > _ref; ci = 0 <= _ref ? ++_i : --_i) {
        c = this.set[ci];
        sr = matching(c, searchTerm, hitTag);
        if (sr && (sr.score > minscore || retar.length < nresults)) {
          insertat = 0;
          for (insertat = _j = 0, _ref1 = retar.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; insertat = 0 <= _ref1 ? ++_j : --_j) {
            if (retar[insertat].score < sr.score) {
              break;
            }
          }
          sr.key = c.key;
          sr.text = c.text;
          retar.splice(insertat, 0, sr);
          if (retar.length > nresults) {
            retar.pop();
          }
          minscore = retar[retar.length - 1].score;
        }
      }
      return retar;
    };

    MatchSet.prototype.seekBestKey = function(term) {
      var res;
      res = this.seek(term, 1);
      if (res.length > 0) {
        return res[0].key;
      } else {
        return null;
      }
    };

    return MatchSet;

  })();

  this.matchset = function(args) {
    return new this.MatchSet(args);
  };

}).call(this);
